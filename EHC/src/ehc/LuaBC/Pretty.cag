%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Lua bytecode Pretty Printer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 core) hs module {%{EH}LuaBC.Pretty} import(UHC.Util.Pretty,{%{EH}LuaBC})
%%]
%%[(8 core) hs import({%{EH}Ty.Pretty})
%%]

%%[(8 core).WRAPPER ag import({LuaBC/AbsSyn})
WRAPPER
  CChunk
%%]

%%[(8 core) hs export(ppCChunk)
ppCChunk :: CChunk -> PP_Doc
ppCChunk chunk
  = pp_Syn_CChunk t
  where t = wrap_CChunk (sem_CChunk chunk)
              (Inh_CChunk {})
%%]

%%[(8 core) ag
ATTR CChunk [ | | pp : {PP_Doc} ]
SEM CChunk
  | Chunk lhs.pp = text "Main prototype" >-< (indent 2 @main.pp)

ATTR CPrototype [ | | pp : {PP_Doc} ]
SEM CPrototype
  | Prototype lhs.pp =
      text "sourceName:" >#< text @sourceName >-<
      text "lineDefined:" >#< (text $ show @lineDefined) >-<
      text "lastLineDefined:" >#< (text $ show @lastLineDefined) >-<
      text "numUpvalues:" >#< (text $ show @numUpvalues) >-<
      text "numParams:" >#< (text $ show @numParams) >-<
      text "flagVararg:" >#< @flagVararg.pp >-<
      text "maxStackSize:" >#< (text $ show @maxStackSize) >-<
      text "instructions:" >-< (indent 2 @instructions.pp) >-<
      text "constants:" >-< (indent 2 @constants.pp) >-<
      text "prototypes:" >-< (indent 2 @prototypes.pp) >-<
      text "sourcePos:" >-< (indent 2 $ ppVertically $ map (text . show) @sourcePos) >-<
      text "locals:" >-< (indent 2 @locals.pp) >-<
      text "upvalues:" >-< (indent 2 $ ppVertically $ map text @upvalues)
  | Prototype prototypes.ppCounter = 0
  | Prototype constants.ppCounter = 0

ATTR CPrototypeL [ ppCounter : {Int} | | pp : {PP_Doc} ]
SEM CPrototypeL
  | Nil lhs.pp = empty
  | Cons lhs.pp = text "Prototype" >#< (text $ show @lhs.ppCounter) >|< ":" >-< (indent 2 @hd.pp) >-< @tl.pp
  | Cons tl.ppCounter = @lhs.ppCounter + 1

ATTR CVarArgFlag [ | | pp : {PP_Doc} ]
SEM CVarArgFlag
  | VarArgFlag lhs.pp =
      text "(" >|<
      (text $ show @hasArg) >|< "," >#<
      (text $ show @isVarArg) >|< "," >#<
      (text $ show @needsArg) >|< ")"

ATTR CInstruction [ | | pp : {PP_Doc} ]
SEM CInstruction
  | Move lhs.pp = text "Move" >#< ppCommas' [text $ show @regTarget, text $ show @regSource]
  | LoadK lhs.pp = text "LoadK" >#< ppCommas' [text $ show @regTarget, text $ show @constSource]
  | LoadBool lhs.pp = text "LoadBool" >#< ppCommas' [text $ show @regTarget, text $ show @value, text $ show @skipNext]
  | GetGlobal lhs.pp = text "GetGlobal" >#< ppCommas' [text $ show @regTarget, text $ show @constName]
  | SetGlobal lhs.pp = text "SetGlobal" >#< ppCommas' [text $ show @regSource, text $ show @constName]
  | GetUpval lhs.pp = text "GetUpval" >#< ppCommas' [text $ show @regTarget, text $ show @upvalSource]
  | SetUpval lhs.pp = text "SetUpval" >#< ppCommas' [text $ show @regSource, text $ show @upvalTarget]
  | GetTable lhs.pp = text "GetTable" >#< ppCommas' [text $ show @regTarget, text $ show @regTable, @rkKey.pp]
  | SetTable lhs.pp = text "SetTable" >#< ppCommas' [text $ show @regTable, @rkKey.pp, @rkValue.pp]
  | Return lhs.pp = text "Return" >#< ppCommas' [text $ show @regReturn, text $ show @numReturns]
  | Call lhs.pp = text "Call" >#< ppCommas' [text $ show @regFunction, text $ show @numArguments, text $ show @numResults]
  | TailCall lhs.pp = text "TailCall" >#< ppCommas' [text $ show @regFunction, text $ show @numArguments]
  | Comment lhs.pp = text "//" >#< text @data
  | Closure lhs.pp = text "Closure" >#< ppCommas' [text $ show @regTarget, text $ show @protoIndex]

ATTR CInstructionL [ | | pp : {PP_Doc} ]
SEM CInstructionL
  | Nil lhs.pp = empty
  | Cons lhs.pp = @hd.pp >-< @tl.pp

ATTR CConstant [ | | pp : {PP_Doc} ]
SEM CConstant
  | Nil lhs.pp = text "Nil"
  | Boolean lhs.pp = text $ show @value
  | Number lhs.pp = text $ show @value
  | String lhs.pp = text "\"" >|< text @value >|< text "\""

ATTR CConstantL [ ppCounter : {Int} | | pp : {PP_Doc} ]
SEM CConstantL
  | Nil lhs.pp = empty
  | Cons lhs.pp = (text $ show @lhs.ppCounter) >|< ":" >#< @hd.pp >-< @tl.pp
  | Cons tl.ppCounter = @lhs.ppCounter + 1

ATTR CRegOrConst [ | | pp : {PP_Doc} ]
SEM CRegOrConst
  | Reg lhs.pp = text "Reg(" >|< (text $ show @index) >|< ")"
  | Const lhs.pp = text "Const(" >|< (text $ show @index) >|< ")"

ATTR CLocal [ | | pp : {PP_Doc} ]
SEM CLocal
  | Local lhs.pp = text @varname >#< (text $ show @startpc) >#< text "-" >#< (text $ show @endpc)

ATTR CLocalL [ ppCounter : {Int} | | pp : {PP_Doc} ]
SEM CLocalL
  | Nil lhs.pp = empty
  | Cons lhs.pp = (text $ show @lhs.ppCounter) >|< text ":" >#< @hd.pp >-< @tl.pp
        
%%]
