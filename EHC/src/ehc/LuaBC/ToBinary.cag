%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%
%%% Binary file generation
%%%%%%

%%[(8 core) hs module {%{EH}LuaBC.ToBinary} import({%{EH}LuaBC})
%%]
%%[(8 core) hs import (qualified UHC.Util.FastSeq as Seq)
%%]
%%[(8 core) hs import ({%{EH}CodeGen.Bits})
%%]
%%[(8 core) hs import (Data.Char)
%%]
%%[(8 core) hs import (Data.Bits, Unsafe.Coerce, Data.Word (Word64))
%%]

%%%%%%
%%% Interface
%%%%%%

%%[(8 core).WRAPPER ag import({LuaBC/AbsSyn})
WRAPPER CChunk
%%]

%%[(8 core) hs export(chunk2binary)
chunk2binary :: CChunk -> Bytes
chunk2binary chunk
  = binary_Syn_CChunk t
  where t = wrap_CChunk (sem_CChunk chunk) (Inh_CChunk {})
%%]

%%[(8 core) hs
encodeU1 :: Integral n => n -> Bytes
encodeU1 x = stringToBytes [chr $ fromIntegral x .&. 0xFF]

encodeU2 :: (Integral n, Bits n) => n -> Bytes
encodeU2 x
  = (encodeU1 least) ## (encodeU1 most)
  where (most, least) = (x .&. 0xFFFF) `divMod` 0x100

encodeU4 :: (Integral n, Bits n) => n -> Bytes
encodeU4 x
  = (encodeU2 least) ## (encodeU2 most)
  where (most, least) = (x .&. 0xFFFFFFFF) `divMod` 0x10000

encodeU8 :: (Integral n, Bits n) => n -> Bytes
encodeU8 x
  = (encodeU4 least) ## (encodeU4 most)
  where (most, least) = x `divMod` 0x100000000


encodeByte :: Int -> Bytes
encodeByte = encodeU1

encodeInt :: Int -> Bytes
encodeInt = encodeU4

encodeSizeT :: Int -> Bytes
encodeSizeT = encodeU8

encodeInstr :: Int -> Bytes
encodeInstr = encodeU4

encodeInstrABC :: Int -> Int -> Int -> Int -> Bytes
encodeInstrABC opcode a b c
  = encodeInstr $
      ((fromIntegral opcode) .&. 0x3F) .|.
      (((fromIntegral a) .&. 0xFF) `shift` 6) .|.
      (((fromIntegral c) .&. 0x1FF) `shift` 14) .|.
      (((fromIntegral b) .&. 0x1FF) `shift` 23)

encodeInstrABx :: Int -> Int -> Int -> Bytes
encodeInstrABx opcode a b
  = encodeInstr $
      ((fromIntegral opcode) .&. 0x3F) .|.
      (((fromIntegral a) .&. 0xFF) `shift` 6) .|.
      (((fromIntegral b) .&. 0x3FFFF) `shift` 14)

encodeInstrAsBx :: Int -> Int -> Int -> Bytes
encodeInstrAsBx opcode a b
  = encodeInstr $
      ((fromIntegral opcode) .&. 0x3F) .|.
      (((fromIntegral a) .&. 0xFF) `shift` 6) .|.
      (((fromIntegral ub) .&. 0x3FFFF) `shift` 14)
  where
    ub = if b < 0 then bias + b else b 
    bias = 0x3FFFF `div` 2

doubleToWord :: Double -> Word64
doubleToWord x = unsafeCoerce x

encodeNumber :: Double -> Bytes
encodeNumber n = encodeU8 $ doubleToWord n

encodeString :: String -> Bytes
encodeString str = (encodeSizeT ((length str) + 1)) ## (stringToBytes $ str ++ [chr 0])

%%]

%%[(8 core) ag
ATTR CChunk [ | | binary : {Bytes} ]
SEM CChunk
  | Chunk loc.header =
      stringToBytes
        [ chr 0x1B, 'L', 'u', 'a' -- Header signature
        , chr 0x51 -- Version number
        , chr 0 -- Format version
        , chr 1 -- Endianness flag, little endian
        , chr (bytesSize $ encodeInt 0) -- Size of integer
        , chr (bytesSize $ encodeSizeT 0) -- Size of size_t
        , chr (bytesSize $ encodeInstr 0) -- Size of instruction
        , chr (bytesSize $ encodeNumber 0.0) -- Size of number
        , chr 0 -- integral flag
        ]
  | Chunk lhs.binary = @loc.header ## @main.binary

ATTR CPrototype [ | | binary : {Bytes} ]
SEM CPrototype
  | Prototype lhs.binary =
      encodeString @sourceName ##
      encodeInt @lineDefined ##
      encodeInt @lastLineDefined ##
      encodeByte @numUpvalues ##
      encodeByte @numParams ##
      @flagVararg.binary ##
      encodeByte @maxStackSize ##
      (encodeInt @instructions.length) ##
      @instructions.binary ##
      (encodeInt @constants.length) ##
      @constants.binary ##
      --stringToBytes "protoprotoproto" ##
      (encodeInt @prototypes.length) ##
      @prototypes.binary ##
      (encodeInt (length @sourcePos)) ##
      (foldl (##) (stringToBytes []) $ map encodeInt @sourcePos) ##
      (encodeInt @locals.length) ##
      @locals.binary ##
      (encodeInt (length @upvalues)) ##
      (foldl (##) (stringToBytes []) $ map encodeString @upvalues)


ATTR CVarArgFlag [ | | binary : {Bytes} ]
SEM CVarArgFlag
  | VarArgFlag lhs.binary =
      encodeByte $ (
        (if @hasArg then 1 else 0) +
        (if @isVarArg then 2 else 0) +
        (if @needsArg then 4 else 0)
      )

ATTR CInstructionL CConstantL CPrototypeL CLocalL [ | | binary USE {##} {stringToBytes []} : {Bytes} ]
ATTR CConstantL CPrototypeL CLocalL [ | | length : {Int} ]
SEM CConstantL CPrototypeL CLocalL
  | Cons lhs.length = 1 + @tl.length
  | Nil lhs.length = 0
ATTR CInstructionL [ | | length USE {+} {0} : {Int} ]
ATTR CInstruction [ | | binary : {Bytes} length : {Int} ]
SEM CInstruction
  | Move lhs.binary = encodeInstrABC 0 @regTarget @regSource 0
  | LoadK lhs.binary = encodeInstrABx 1 @regTarget @constSource
  | LoadBool lhs.binary = encodeInstrABC 2 @regTarget (if @value then 1 else 0) (if @skipNext then 1 else 0)
  | GetUpval lhs.binary = encodeInstrABC 4 @regTarget @upvalSource 0
  | GetGlobal lhs.binary = encodeInstrABx 5 @regTarget @constName
  | Call lhs.binary = encodeInstrABC 28 @regFunction @numArguments @numResults
  | TailCall lhs.binary = encodeInstrABC 29 @regFunction @numArguments 0
  | Return lhs.binary = encodeInstrABC 30 @regReturn @numReturns 0
  | Closure lhs.binary = encodeInstrABx 36 @regTarget @protoIndex
  | Comment lhs.binary = stringToBytes []
  | * - Comment lhs.length = 1
  | Comment lhs.length = 0

ATTR CConstant [ | | binary : {Bytes} ]
SEM CConstant
  | Nil lhs.binary = stringToBytes [chr 0]
  | Boolean lhs.binary = stringToBytes [chr 1, chr $ if @value then 1 else 0]
  | Number lhs.binary = (stringToBytes [chr 3]) ## encodeNumber @value
  | String lhs.binary = (stringToBytes [chr 4]) ## encodeString @value

ATTR CLocal [ | | binary : {Bytes} ]
SEM CLocal
  | Local lhs.binary = (encodeString @varname) ## (encodeInt @startpc) ## (encodeInt @endpc)
  
%%]
