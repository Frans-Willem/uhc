%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MSCIL Pretty Printer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 core) hs module {%{EH}MSCIL.Pretty} import(UHC.Util.Pretty,{%{EH}MSCIL}, Numeric)
%%]
%%[(8 core) hs import({%{EH}Ty.Pretty})
%%]

%%[(8 core).WRAPPER ag import({MSCIL/AbsSyn})
WRAPPER
  DeclL
%%]

%%[(8 core) hs export(ppDeclL)
ppDeclL :: DeclL -> PP_Doc
ppDeclL l
  = ppVertically $ pp_Syn_DeclL t
  where t = wrap_DeclL (sem_DeclL l)
              (Inh_DeclL {})
%%]

%%[(8 core) ag
ATTR Id [ | | pp : {PP_Doc} ]
SEM Id
  | Id lhs.pp = text "'" >|< text @value >|< text "'"

ATTR DottedName [ | | pp : {PP_Doc} isNil : {Bool} ]
SEM DottedName
  | Nil lhs.isNil = True
  | Cons lhs.isNil = False
  | Nil lhs.pp = empty
  | Cons lhs.pp =
      case @tl.isNil of
        True -> @hd.pp
        False -> @hd.pp >|< text "." >|< @tl.pp

ATTR DottedNameL [ | | pp USE {:} {[]} : {[PP_Doc]} ]

ATTR Decl [ | | pp : {PP_Doc} ]
SEM Decl
  | Assembly lhs.pp =
      (text ".assembly" >#< @name.pp) >-<
      text "{" >-<
      indent 2 (ppVertically @info.pp) >-<
      text "}"
  | AssemblyExtern lhs.pp =
      (text ".assembly extern" >#< @name.pp) >-<
      text "{" >-<
      indent 2 (ppVertically @info.pp) >-<
      text "}"
  | Class lhs.pp =
      (text ".class" >#< @header.pp) >-<
      text "{" >-<
      indent 2 (ppVertically @members.pp) >-<
      text "}"
  | Field lhs.pp =
      text ".field" >#< @decl.pp
  | Method lhs.pp =
      (text ".method" >#< @header.pp) >-<
      text "{" >-<
      indent 2 (ppVertically @body.pp) >-<
      text "}"
ATTR DeclL [ | | pp USE {:} {[]} : {[PP_Doc]} ]

ATTR AsmDecl [ | | pp : {PP_Doc} ]
SEM AsmDecl
  | Ver lhs.pp = text ".ver" >#< (ppListSep "" "" ":" $ map (text . show) [@a,@b,@c,@d])
  | HashAlgorithm lhs.pp = text ".hash algorithm 0x" >|< (showHex @algo "")
ATTR AsmDeclL [ | | pp USE {:} {[]} : {[PP_Doc]} ]

ATTR AsmRefDecl [ | | pp : {PP_Doc} ]
SEM AsmRefDecl
  | Ver lhs.pp = text ".ver" >#< (ppListSep "" "" ":" $ map (text . show) [@a,@b,@c,@d])
  | PubKeyToken lhs.pp = text ".publickeytoken =" >#< (ppListSep "(" ")" " " $ map (\x -> text $ showHex x "") @token)
ATTR AsmRefDeclL [ | | pp USE {:} {[]} : {[PP_Doc]} ]

ATTR ClassHeader [ | | pp : {PP_Doc} ]
SEM ClassHeader
  | ClassHeader lhs.pp =
      foldr
        (>#<)
        (foldl
          (>|<)
          @name.pp
          ( zipWith
              (>#<)
              ((text " extends"):(text " implements"):(repeat $ text ", "))
              @extends.pp
          )
        )
        @attrs.pp

ATTR ClassAttr [ | | pp : {PP_Doc} ]
ATTR ClassAttrL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM ClassAttr
  | Abstract lhs.pp = text "abstract"
  | Ansi lhs.pp = text "ansi"
  | Auto lhs.pp = text "auto"
  | Explicit lhs.pp = text "explicit"
  | Interface lhs.pp = text "interface"
  | Private lhs.pp = text "private"
  | Public lhs.pp = text "public"

ATTR ClassMember [ | | pp : {PP_Doc} ]
ATTR ClassMemberL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM ClassMember
  | Class lhs.pp =
      (text ".class" >#< @header.pp) >-<
      text "{" >-<
      indent 2 (ppVertically @members.pp) >-<
      text "}"
  | Field lhs.pp =
      text ".field" >#< @decl.pp
  | Method lhs.pp =
      (text ".method" >#< @header.pp) >-<
      text "{" >-<
      indent 2 (ppVertically @body.pp) >-<
      text "}"

ATTR FieldDecl [ | | pp : {PP_Doc} ]
SEM FieldDecl
  | FieldDecl lhs.pp =
      (case @byteOffset of
        Nothing -> empty
        Just x -> text "[" >|< (text $ show x) >|< text "] "
      )
      >|<
      foldr (>#<) (@ty.pp >#< @name.pp) @attrs.pp

ATTR FieldAttr [ | | pp : {PP_Doc} ]
ATTR FieldAttrL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM FieldAttr
  | Family lhs.pp = text "family"
  | Private lhs.pp = text "private"
  | Public lhs.pp = text "public"
  | RtSpecialName lhs.pp = text "rtspecialname"
  | SpecialName lhs.pp = text "specialname"
  | Static lhs.pp = text "static"

ATTR Type [ | | pp : {PP_Doc} ]
ATTR TypeL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM Type
  | GenTypeParam lhs.pp = text "!" >|< (text $ show @index)
  | GenMethodParam lhs.pp = text "!!" >|< (text $ show @index)
  | Bool lhs.pp = text "bool"
  | Char lhs.pp = text "char"
  | Class lhs.pp = text "class" >#< @ref.pp
  | NativeInt lhs.pp = text "native int"
  | NativeUInt lhs.pp = text "native unsigned int"
  | Object lhs.pp = text "object"
  | String lhs.pp = text "string"
  | GenType lhs.pp = @base.pp >|< ppListSep "<" ">" ", " @args.pp
  | Void lhs.pp = text "void"

ATTR TypeSpec [ | | pp : {PP_Doc} ]
ATTR TypeSpecL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM TypeSpec
  | External lhs.pp = ppBrackets @module.pp
  | Ref lhs.pp = @ref.pp
  | Type lhs.pp = @ty.pp

ATTR MbTypeSpec MbCallConv MbId MbResolutionScope [ | | pp : {Maybe PP_Doc} ]
SEM MbTypeSpec MbCallConv MbId MbResolutionScope
  | Just lhs.pp = Just @just.pp
  | Nothing lhs.pp = Nothing

ATTR TypeReference [ | | pp : {PP_Doc} ]
SEM TypeReference
  | Ref loc.prefixScope = maybe id (>#<) @scope.pp
  | Ref lhs.pp = @loc.prefixScope $ ppListSep "" "" "/" @name.pp

ATTR ResolutionScope [ | | pp : {PP_Doc} ]
SEM ResolutionScope
  | Module lhs.pp = text "[.module" >#< @fname.pp >#< text "]"
  | AssemblyRefName lhs.pp = ppBrackets @name.pp

ATTR AssemblyRefName [ | | pp : {PP_Doc} ]

ATTR MethodHeader [ | | pp : {PP_Doc} ]
SEM MethodHeader
  | MethodHeader loc.prefixConv = maybe id (>#<) @conv.pp
  | MethodHeader lhs.pp =
      foldr
        (>#<)
        (
          @loc.prefixConv $
            @ty.pp >#< @name.pp >|<
            ppParensCommas' @params.pp
        )
        @attr.pp

ATTR MethodName [ | | pp : {PP_Doc} ]
SEM MethodName
  | Cctor lhs.pp = text ".cctor"
  | Ctor lhs.pp = text ".ctor"
  | Name lhs.pp = @name.pp

ATTR Param [ | | pp : {PP_Doc} ]
ATTR ParamL [ | | pp USE {:} {[]} : {[PP_Doc]} ] 
SEM Param
  | Param lhs.pp = 
      foldr (>#<)
      (
        case @id of
          Nothing -> @ty.pp
          Just id -> @ty.pp >#< id
      ) 
      @attrs.pp

ATTR ParamAttr [ | | pp : {PP_Doc} ]
ATTR ParamAttrL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM ParamAttr
  | In lhs.pp = text "in"
  | Opt lhs.pp = text "opt"
  | Out lhs.pp = text "out"

ATTR MethodBodyItem [ | | pp : {PP_Doc} ]
ATTR MethodBodyItemL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM MethodBodyItem
  | EntryPoint lhs.pp = text ".entrypoint"
  | Locals lhs.pp = text (if @init then ".locals init" else ".locals") >#< ppParensCommas' @locals.pp
  | MaxStack lhs.pp = text ".maxstack" >#< (text $ show @size)
  | Instr lhs.pp = @instr.pp
  | Label lhs.pp = @id.pp >|< ":"
  | Comment lhs.pp = text "//" >#< text @data
  | Raw lhs.pp = text @data

ATTR Instruction [ | | pp : {PP_Doc} ]
SEM Instruction
  | Add lhs.pp = text "add"
  | AddOvf lhs.pp = text "add.ovf"
  | And lhs.pp = text "and"
  | CEq lhs.pp = text "ceq"
  | CGt lhs.pp = text "cgt"
  | CGtUn lhs.pp = text "cgt.un"
  | CLt lhs.pp = text "clt"
  | CLtUn lhs.pp = text "clt.un"
  | Div lhs.pp = text "div"
  | DivUn lhs.pp = text "div.un"
  | Dup lhs.pp = text "dup"
  | LdNull lhs.pp = text "ldnull"
  | Mul lhs.pp = text "mul"
  | MulOvf lhs.pp = text "mul.ovf"
  | MulOvfUn lhs.pp = text "mul.ovf.un"
  | Neg lhs.pp = text "neg"
  | Nop lhs.pp = text "nop"
  | Not lhs.pp = text "not"
  | Or lhs.pp = text "or"
  | Pop lhs.pp = text "pop"
  | Rem lhs.pp = text "rem"
  | RemUn lhs.pp = text "rem.un"
  | Ret lhs.pp = text "ret"
  | Shl lhs.pp = text "shl"
  | Shr lhs.pp = text "shr"
  | ShrUn lhs.pp = text "shr.un"
  | Sub lhs.pp = text "sub"
  | SubOvf lhs.pp = text "sub.ovf"
  | SubOvfUn lhs.pp = text "sub.ovf.un"
  | Tail lhs.pp = text "tail."
  | Xor lhs.pp = text "xor"
  | LdArg LdArgA LdLoc LdLocA StArg StLoc loc.shortmin = 0
  | LdArg LdArgA LdLoc LdLocA StArg StLoc loc.shortmax = 255
  | LdArg LdArgA LdLoc LdLocA StArg StLoc loc.staticmin = 0
  | LdArg LdArgA LdLoc LdLocA StArg StLoc loc.staticmax = 3
  | LdArg lhs.pp =
      case @arg.shortpp of
        Just short -> text "ldarg" >|< @arg.shortpp
        Nothing -> text "ldarg" >#< @arg.pp
  | LdArgA lhs.pp =
      case @arg.shortpp of
        Just short -> text "ldarga" >|< @arg.shortpp
        Nothing -> text "ldarga" >#< @arg.pp
  | LdLoc lhs.pp =
      case @local.shortpp of
        Just short -> text "ldloc" >|< @local.shortpp
        Nothing -> text "ldloc" >#< @local.pp
  | LdLocA lhs.pp =
      case @local.shortpp of
        Just short -> text "ldloca" >|< @local.shortpp
        Nothing -> text "ldloca" >#< @local.pp
  | StArg lhs.pp =
      case @arg.shortpp of
        Just short -> text "starg" >|< @arg.shortpp
        Nothing -> text "starg" >#< @arg.pp
  | StLoc lhs.pp =
      case @local.shortpp of
        Just short -> text "stloc" >|< @local.shortpp
        Nothing -> text "stloc" >#< @local.pp
  | LdcI4 lhs.pp =
      if (@value >= 0 && @value<=8)
        then text "ldc.i4." >|< (text $ show @value)
        else
          if (@value == -1)
            then text "ldc.i4.m1"
            else
              if (@value >= -127 && @value <= 127)
                then text "ldc.i4.s"
                else text "ldc.i4"
              >#< (text $ show @value)
  | Unaligned lhs.pp = text ".unaligned" >#< (text $ show @alignment)
  | LdcI8 lhs.pp = text "ldc.i8" >#< (text $ show @value)
  | LdcR4 lhs.pp = text "ldc.r4" >#< (text $ show @value)
  | LdcR8 lhs.pp = text "ldc.r8" >#< (text $ show @value)
  | BrFalse BrTrue Br loc.shortmin = -127
  | BrFalse BrTrue Br loc.shortmax = 127
  | BrFalse BrTrue Br loc.staticmin = 0
  | BrFalse BrTrue Br loc.staticmax = -1
  | BrFalse BrTrue Br lhs.pp =
      case @target.shortpp of
        Just short -> @loc.mypp >|< @target.shortpp
        Nothing -> @loc.mypp >#< @target.pp
  | BrFalse loc.mypp = text "brfalse"
  | BrTrue loc.mypp = text "brtrue"
  | Br loc.mypp = text "br"
  | Call CallVirt Jmp LdFtn LdVirtFtn NewObj loc.prefixcls =
      maybe id (\x y -> x >|< text "::" >|< y) @cls.pp
  | Call CallVirt Jmp LdFtn LdVirtFtn NewObj lhs.pp =
      @loc.mypp >#< @conv.pp >#< @ret.pp >#< @loc.prefixcls @name.pp >|< ppParensCommas' @params.pp
  | Call loc.mypp = text "call"
  | CallVirt loc.mypp = text "callvirt"
  | Jmp loc.mypp = text "jmp"
  | LdFtn loc.mypp = text "ldftn"
  | LdVirtFtn loc.mypp = text "ldvirtftn"
  | NewObj loc.mypp = text "newobj"
  | LdStr lhs.pp = text "ldstr" >#< (text $ show @value)
  | LdFld lhs.pp = text "ldfld" >#< @ty.pp >#< @cls.pp >|< text "::" >|< @id.pp
  | StFld lhs.pp = text "stfld" >#< @ty.pp >#< @cls.pp >|< text "::" >|< @id.pp
  | Box lhs.pp = text "box" >#< @cls.pp
  | UnboxAny lhs.pp = text "unbox.any" >#< @cls.pp
  | IsInst lhs.pp = text "isinst" >#< @cls.pp

ATTR EIntId [ shortmin : {Int} shortmax : {Int} | | ]
ATTR EIntId [ staticmin : {Int} staticmax : {Int} | | ]
ATTR EIntId [ | | pp : {PP_Doc} shortpp : {Maybe PP_Doc} ]
SEM EIntId
  | Left lhs.pp = text (show @left)
  | Left lhs.shortpp =
      if @left >= @lhs.staticmin && @left <= @lhs.staticmax
        then (Just (text "." >|< (text $ show @left)))
        else
          if @left >= @lhs.shortmin && @left <= @lhs.shortmax
            then (Just (text ".s" >#< (text $ show @left)))
            else Nothing
  | Right lhs.pp = @right.pp
  | Right lhs.shortpp = Nothing

ATTR CallConv [ | | pp : {PP_Doc} ]
SEM CallConv
  | CallConv lhs.pp = (if @instance then text "instance " else empty) >|< (if @explicit then text "explicit " else empty) >|< @kind.pp

ATTR CallKind [ | | pp : {PP_Doc} ]
SEM CallKind
  | Default lhs.pp = text "default"

ATTR Local [ | | pp : {PP_Doc} ]
SEM Local
  | Local lhs.pp =
      case @id of
        Nothing -> @ty.pp
        Just x -> @ty.pp >#< x
ATTR LocalL [ | | pp USE {:} {[]} : {[PP_Doc]} ]

ATTR MethAttr [ | | pp : {PP_Doc} ]
ATTR MethAttrL [ | | pp USE {:} {[]} : {[PP_Doc]} ]
SEM MethAttr
  | Abstract lhs.pp = text "abstract"
  | Family lhs.pp = text "family"
  | NewSlot lhs.pp = text "newslot"
  | Private lhs.pp = text "private"
  | Public lhs.pp = text "public"
  | RtSpecialName lhs.pp = text "rtspecialname"
  | SpecialName lhs.pp = text "specialname"
  | Static lhs.pp = text "static"
  | Virtual lhs.pp = text "virtual"
%%]
