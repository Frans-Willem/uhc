%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%
%%% Conversion to MSCIL
%%%

%%[(8 core) hs module {%{EH}CoreCPS.ToMSCIL} import({%{EH}Base.Common} hiding (nextUnique),{%{EH}CoreCPS})
%%]

%%[(8 core) hs import(qualified {%{EH}MSCIL} as MSCIL, Data.Maybe, {%{EH}Base.HsName})
%%]
%%[(8 core) hs import(qualified Data.Map.Strict as Map, qualified Data.Set as Set)
%%]

%%[(8 core).WRAPPER ag import({CoreCPS/AbsSyn})
WRAPPER CTm
%%]

%%[(8 core) hs export(cps2cil)
cps2cil :: CTm -> MSCIL.DeclL
cps2cil tm
  = defaultImports
    ++ defaultAssembly
    ++ defaultClasses
    ++ createTagClasses (tags_Syn_CTm t)
    ++ (classes_Syn_CTm t)
    ++
    [ MSCIL.Decl_Method
        (MSCIL.methodHeader [MSCIL.MethAttr_Static] MSCIL.Type_Void "main" ())
        (
          [ MSCIL.MethodBodyItem_EntryPoint
          , MSCIL.MethodBodyItem_MaxStack (maxstack_Syn_CTm t)
          , MSCIL.MethodBodyItem_Locals False (locals_Syn_CTm t)
          ]
          ++ (instr_Syn_CTm t)
        )
    ]
  where
    t = wrap_CTm (sem_CTm tm) (inh)
    inh = Inh_CTm {env_Inh_CTm = Map.empty, localoffset_Inh_CTm = 0, caseNumber_Inh_CTm = 0}

defaultImports :: MSCIL.DeclL
defaultImports =
  [ MSCIL.Decl_AssemblyExtern
      [MSCIL.convert "mscorlib"]
      [ MSCIL.AsmRefDecl_Ver 4 0 0 0
      , MSCIL.AsmRefDecl_PubKeyToken [0xB7, 0x7A, 0x5C, 0x56, 0x19, 0x34, 0xE0, 0x89]
      ]
  ]

defaultAssembly :: MSCIL.DeclL
defaultAssembly =
  [ MSCIL.Decl_Assembly
      [MSCIL.convert "tempname"]
      [ MSCIL.AsmDecl_Ver 0 0 0 0
      , MSCIL.AsmDecl_HashAlgorithm 0x8004
      ]
  ]

defaultClasses :: MSCIL.DeclL
defaultClasses =
  [ MSCIL.Decl_Class
      (MSCIL.classHeader [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi] continuationBase)
      [ MSCIL.ClassMember_Method
          (MSCIL.ctorHeader ())
          [ MSCIL.instrRet ]
      , MSCIL.ClassMember_Method
          (MSCIL.methodHeader
            [MSCIL.MethAttr_Public, MSCIL.MethAttr_Virtual, MSCIL.MethAttr_NewSlot]
            MSCIL.callConv_Instance
            MSCIL.Type_Void
            "Invoke"
            [(MSCIL.Type_Object,"v")]
          )
          [ MSCIL.instrRet ]
      ]
  , MSCIL.Decl_Class
      (MSCIL.classHeader [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi] thunkBase)
      [ MSCIL.ClassMember_Method
          (MSCIL.ctorHeader ())
          [ MSCIL.instrRet ]
      , MSCIL.ClassMember_Method
          (MSCIL.methodHeader
            [MSCIL.MethAttr_Public, MSCIL.MethAttr_Virtual, MSCIL.MethAttr_NewSlot]
            MSCIL.callConv_Instance
            MSCIL.Type_Void
            "Eval"
            [(continuationBase,"k")]
          )
          [ MSCIL.instrRet ]
      ]
  , MSCIL.Decl_Class
      (MSCIL.classHeader [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi] functionBase)
      [ MSCIL.ClassMember_Method
          (MSCIL.ctorHeader ())
          [ MSCIL.instrRet ]
      , MSCIL.ClassMember_Method
          (MSCIL.methodHeader
            [MSCIL.MethAttr_Public, MSCIL.MethAttr_Virtual, MSCIL.MethAttr_NewSlot]
            MSCIL.callConv_Instance
            MSCIL.Type_Void
            "Invoke"
            [ (continuationBase,"k")
            , (thunkBase,"t")
            ]
          )
          [ MSCIL.instrRet ]
      ]
  ]

continuationBase :: MSCIL.Id
continuationBase = MSCIL.convert "BaseContinuation"

thunkBase :: MSCIL.Id
thunkBase = MSCIL.convert "BaseThunk"

functionBase :: MSCIL.Id
functionBase = MSCIL.convert "BaseFunction"
%%]

%%[(8 core) hs
data DataLocation
  = Local Int
  | Argument Int
  | Field DataLocation MSCIL.TypeSpec MSCIL.Id

data EnvironmentKey
  = ValueKey ValueName
  | ThunkKey ThunkName
  | ContinuationKey ContName

instance Eq EnvironmentKey where
  (==) (ValueKey (ValueName a)) (ValueKey (ValueName b)) = a == b
  (==) (ThunkKey (ThunkName a)) (ThunkKey (ThunkName b)) = a == b
  (==) (ContinuationKey (ContName a)) (ContinuationKey (ContName b)) = a == b
  (==) _ _ = False

instance Ord EnvironmentKey where
  compare (ValueKey (ValueName a)) (ValueKey (ValueName b)) = compare a b
  compare (ThunkKey (ThunkName a)) (ThunkKey (ThunkName b)) = compare a b
  compare (ContinuationKey (ContName a)) (ContinuationKey (ContName b)) = compare a b
  compare (ValueKey _) _ = LT
  compare (ThunkKey _) _ = GT
  compare _ (ValueKey _) = GT
  compare _ (ThunkKey _) = LT

class ToEnvKey a where
  asKey :: a -> EnvironmentKey

instance ToEnvKey ValueName where
  asKey = ValueKey
instance ToEnvKey ThunkName where
  asKey = ThunkKey
instance ToEnvKey ContName where
  asKey = ContinuationKey

instance Show EnvironmentKey where
  show (ValueKey (ValueName nm)) = "value " ++ show nm
  show (ThunkKey (ThunkName nm)) = "thunk " ++ show nm
  show (ContinuationKey (ContName nm)) = "continuation " ++ show nm

type Environment = Map.Map EnvironmentKey DataLocation

-- Gets current stacksize, puts variable on top of stack, and returns instructions and maximum stack size used.
readVar :: MSCIL.Type -> DataLocation -> (MSCIL.MethodBodyItemL, Int)
readVar _ (Local index) = ([MSCIL.instrLdLoc index], 1)
readVar _ (Argument index) = ([MSCIL.instrLdArg index], 1)
readVar ty (Field ownerloc ownercls fieldid)
  = (ownerinstr ++ [MSCIL.instrLdFld ty ownercls fieldid], max 1 ownermaxstack)
  where
    (ownerinstr, ownermaxstack) = readVar (maybe MSCIL.Type_Object id $ MSCIL.typeSpec2type ownercls) ownerloc

readEnv :: Environment -> EnvironmentKey -> (MSCIL.MethodBodyItemL, Int)
readEnv env key
  = case (Map.lookup key env) of
      Just x -> readVar (keyToType key) x
      Nothing -> readUndefinedVar key

readUndefinedVar :: EnvironmentKey -> (MSCIL.MethodBodyItemL, Int)
readUndefinedVar (ValueKey name) = ((debugOutputInstrs ("ERROR: Undefined value " ++ (show name))) ++ [MSCIL.instrRet], 1)
-- TODO: Instantiate thunk or continuation which will error when invoked.
readUndefinedVar key = ([MSCIL.instrLdNull, MSCIL.MethodBodyItem_Comment ("Undefined " ++ (show key))], 1)

instance MSCIL.Convertible EnvironmentKey MSCIL.Id where
  convert (ValueKey (ValueName nm)) = MSCIL.convert $ show nm
  convert (ThunkKey (ThunkName nm)) = MSCIL.convert $ show nm
  convert (ContinuationKey (ContName nm)) = MSCIL.convert $ show nm

instance MSCIL.Convertible EnvironmentKey MSCIL.DottedName where
  convert = (:[]) . MSCIL.convert

instance MSCIL.Convertible EnvironmentKey MSCIL.Type where
  convert (ValueKey _) = MSCIL.Type_Object
  convert (ThunkKey _) = MSCIL.typeClass thunkBase
  convert (ContinuationKey _) = MSCIL.typeClass continuationBase

instance MSCIL.Convertible EnvironmentKey MSCIL.Param where convert key = MSCIL.convert (key, key)

instance MSCIL.Convertible EnvironmentKey MSCIL.Local where
  convert key = MSCIL.convert (key, key)

instance MSCIL.Convertible EnvironmentKey MSCIL.FieldDecl where
  convert key = MSCIL.convert (key, key)

keyToType :: EnvironmentKey -> MSCIL.Type
keyToType = MSCIL.convert

keyToIdentifier :: EnvironmentKey -> MSCIL.Id
keyToIdentifier = MSCIL.convert

keyToLocal :: EnvironmentKey -> MSCIL.Local
keyToLocal = MSCIL.convert

keyToParam :: EnvironmentKey -> MSCIL.Param
keyToParam = MSCIL.convert

keyToField :: EnvironmentKey -> MSCIL.ClassMember
keyToField v = MSCIL.ClassMember_Field (MSCIL.FieldDecl_FieldDecl Nothing [MSCIL.FieldAttr_Private] (keyToType v) (keyToIdentifier v))

continuationClassName :: ContName -> MSCIL.Id
continuationClassName (ContName name) = MSCIL.convert $ "Continuation" ++ (show name)

thunkClassName :: ThunkName -> MSCIL.Id
thunkClassName (ThunkName name) = MSCIL.convert $ "Thunk" ++ (show name)

functionClassName :: ValueName -> MSCIL.Id
functionClassName (ValueName name) = MSCIL.convert $ "Function" ++ (show name)


tagClassName :: CTag -> Int -> MSCIL.Id
tagClassName CTagRec arguments = MSCIL.convert $ "Record" ++ (show arguments)
tagClassName (CTag {ctagTyNm = tyNm, ctagNm = nm }) _ = MSCIL.convert $ (show tyNm) ++ "_" ++ (show nm)

tagFieldName :: Int -> MSCIL.Id
tagFieldName n = MSCIL.convert $ "field" ++ (show n)

createTagClass :: CTag -> Int -> MSCIL.Decl
createTagClass tag arguments =
  MSCIL.Decl_Class
    ( MSCIL.classHeader
        [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi]
        classname
    )
    ( argfields
      ++
      [ MSCIL.ClassMember_Method
          ( MSCIL.ctorHeader argparams )
          (
            [ MSCIL.MethodBodyItem_MaxStack 2
            ] ++
            storeinstrs ++ 
            [ MSCIL.instrRet
            ]
          )
      ]
    )
  where
    classname = tagClassName tag arguments
    argname i = tagFieldName i
    argnames = map argname [1..arguments]
    argfield i = MSCIL.ClassMember_Field $ MSCIL.fieldDecl thunkBase (tagFieldName i)
    argfields = map argfield [1..arguments]
    argparam :: Int -> MSCIL.Param
    argparam i = MSCIL.param thunkBase (tagFieldName i)
    argparams = map argparam [1..arguments]
    storeinstrs = concat $ map storeinstr (zip argnames [1..])
    storeinstr (fieldname, index) =
      [ MSCIL.instrLdArg 0
      , MSCIL.instrLdArg index
      , MSCIL.instrStFld thunkBase classname fieldname
      ]

createTagClasses :: (Set.Set (CTag, Int)) -> MSCIL.DeclL
createTagClasses s
  = map (\(tag, args) -> createTagClass tag args) $ Set.toList s

systemConsoleRefType :: MSCIL.TypeReference
systemConsoleRefType
  = MSCIL.TypeReference_Ref (Just $ MSCIL.ResolutionScope_AssemblyRefName corlibRefName) [MSCIL.convert ["System", "Console"]]
  where
    corlibRefName :: MSCIL.AssemblyRefName
    corlibRefName = MSCIL.AssemblyRefName_AssemblyRefName $ MSCIL.convert "corlib"


debugOutputInstrs :: String -> MSCIL.MethodBodyItemL
debugOutputInstrs s
  =
    [ MSCIL.instrLdStr s
    , MSCIL.instrCall () MSCIL.Type_Void systemConsoleRefType "WriteLine" [MSCIL.Type_Object]
    ]
    
typeSpecInt :: MSCIL.TypeSpec
typeSpecInt = MSCIL.TypeSpec_Ref $ MSCIL.TypeReference_Ref (Just $ MSCIL.ResolutionScope_AssemblyRefName $ MSCIL.AssemblyRefName_AssemblyRefName $ MSCIL.convert "mscorlib") [MSCIL.convert ["System","Int32"]]
%%]

%%[(8 core) ag
{- List of tags being used -}

ATTR CTm CVal CThunkBind CThunkBindL CCaseBranch CCaseBranchL CCasePattern [ | | tags USE {Set.union} {Set.empty} : {Set.Set (CTag,Int)} ]
SEM CVal
  | TagVal lhs.tags = Set.singleton (@tag,length @args)
SEM CCasePattern
  | Tag lhs.tags = Set.singleton (@tag, length @args)

ATTR CTm [ env : {Environment} | | ]
ATTR CTm [ | | instr USE {++} {[]} : {MSCIL.MethodBodyItemL} ]
ATTR CTm [ | | classes USE {++} {[]} : {MSCIL.DeclL} ]
ATTR CTm [ localoffset : {Int} | | locals : {MSCIL.LocalL} ]
ATTR CTm [ | | maxstack USE {max} {0} : {Int} ]
----
-- LetVal
----
SEM CTm
  | LetVal loc.valkey = asKey @bindname
  | LetVal body.env = Map.insert @loc.valkey (Local @lhs.localoffset) @lhs.env
  | LetVal lhs.instr =
      @bindvalue.instr ++
      [ MSCIL.instrStLoc @lhs.localoffset ] ++
      @body.instr
  | LetVal lhs.localoffset = @lhs.localoffset + 1
  | LetVal lhs.locals = (keyToLocal @loc.valkey) : @body.locals
  | LetVal bindvalue.name = @bindname
ATTR CVal [ name : {ValueName} | | instr : {MSCIL.MethodBodyItemL} maxstack : {Int} ]
ATTR CVal [ | | classes USE {++} {[]} : {MSCIL.DeclL} ]
ATTR CVal [ env : {Environment} | | ]
SEM CVal
  | IntVal lhs.instr =
      [ MSCIL.instrLdcI4 @value
      , MSCIL.instrBox typeSpecInt
      ]
  | StringVal lhs.instr = [MSCIL.instrLdStr @value]
  | IntVal StringVal lhs.maxstack = 1
  | LamVal loc.classname = functionClassName @lhs.name
  | LamVal loc.contkey = asKey @bindcont
  | LamVal loc.thunkkey = asKey @bindarg
  | LamVal loc.upvalues = Set.toList $ (@body.freevars `Set.difference` (Set.fromList [@loc.contkey, @loc.thunkkey]))
  | LamVal lhs.classes =
      [ MSCIL.Decl_Class
          ( MSCIL.classHeader
            [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi]
            @loc.classname
            [functionBase]
          )
          (
            (map keyToField @loc.upvalues)
            ++
            [ MSCIL.ClassMember_Method
              ( MSCIL.ctorHeader (map keyToParam @loc.upvalues) )
              (
                [  MSCIL.instrLdArg 0
                , MSCIL.instrCall MSCIL.callConv_Instance MSCIL.Type_Void functionBase MSCIL.MethodName_Ctor ()
                ] ++
                ( concat $ map
                    (\(upval, index) -> 
                      [ MSCIL.instrLdArg 0
                      , MSCIL.instrLdArg index
                      , MSCIL.instrStFld upval @loc.classname upval
                      ]
                    )
                    (zip @loc.upvalues [1..])
                ) ++ 
                [ MSCIL.instrRet ]
              )
          , MSCIL.ClassMember_Method
              ( MSCIL.methodHeader
                [MSCIL.MethAttr_Family, MSCIL.MethAttr_Virtual]
                MSCIL.callConv_Instance
                MSCIL.Type_Void
                "Invoke"
                [ keyToParam @loc.contkey
                , keyToParam @loc.thunkkey
                ]
              )
              ( MSCIL.MethodBodyItem_MaxStack @body.maxstack
              : MSCIL.MethodBodyItem_Locals False @body.locals
              : @body.instr
              )
          ]
        )
      ] ++ @body.classes
  | LamVal body.localoffset = 0
  | LamVal body.env =
      Map.fromList $
        (@loc.contkey, Argument 1) :
        (@loc.thunkkey, Argument 2) :
        (zip @loc.upvalues $ map (\upval -> Field (Argument 0) (MSCIL.convert @loc.classname) (MSCIL.convert upval)) @loc.upvalues)
  | LamVal (loc.upvalueinstr, loc.upvaluemaxstack) = unzip $ map (readEnv @lhs.env) @loc.upvalues
  | LamVal lhs.instr =
      (concat @loc.upvalueinstr) ++
      [ MSCIL.instrNewObj MSCIL.callConv_Instance MSCIL.Type_Void @loc.classname MSCIL.MethodName_Ctor @loc.upvalues
      ]
  | LamVal lhs.maxstack = foldr max (length @loc.upvalues) (zipWith (+) @loc.upvaluemaxstack [0..])
SEM CVal
  | TagVal loc.classname = tagClassName @tag $ length @args
  | TagVal loc.argkey = map asKey @args
  | TagVal (loc.arginstr, loc.argmaxstack) = unzip $ map (readEnv @lhs.env) @loc.argkey
  | TagVal lhs.instr =
      (concat @loc.arginstr) ++ 
      [ MSCIL.instrNewObj MSCIL.callConv_Instance MSCIL.Type_Void @loc.classname MSCIL.MethodName_Ctor @loc.argkey
      ]
  | TagVal lhs.maxstack = foldr max (length @args) (zipWith (+) @loc.argmaxstack [0..])
----
-- LetCont
----
SEM CTm
  | LetCont loc.contkey = asKey @contname
  | LetCont loc.valuekey = asKey @valname
  | LetCont lhs.locals = (MSCIL.convert @loc.valuekey) : @body.locals
  | LetCont loc.target = @lhs.localoffset
  | LetCont lhs.localoffset = @lhs.localoffset + 1
  | LetCont loc.classname = continuationClassName @contname
  | LetCont loc.upvalues = Set.toList $ Set.delete @loc.valuekey @bindbody.freevars
  | LetCont loc.class =
      MSCIL.Decl_Class
        ( MSCIL.classHeader
          [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi]
          @loc.classname
          [continuationBase]
        )
        (
          (map (MSCIL.ClassMember_Field . MSCIL.convert) @loc.upvalues) ++
          [ MSCIL.ClassMember_Method
            ( MSCIL.ctorHeader @loc.upvalues )
            (
              [  MSCIL.instrLdArg 0
              , MSCIL.instrCall MSCIL.callConv_Instance MSCIL.Type_Void continuationBase MSCIL.MethodName_Ctor ()
              ] ++
              ( concat $ map
                  (\(upval, index) -> 
                    [ MSCIL.instrLdArg 0
                    , MSCIL.instrLdArg index
                    , MSCIL.instrStFld upval @loc.classname upval
                    ]
                  )
                  (zip @loc.upvalues [1..])
              ) ++ 
              [ MSCIL.instrRet ]
            )
          , MSCIL.ClassMember_Method
            ( MSCIL.methodHeader
              [MSCIL.MethAttr_Family, MSCIL.MethAttr_Virtual]
              MSCIL.callConv_Instance
              MSCIL.Type_Void
              "Invoke"
              [@loc.valuekey]
            )
            ( MSCIL.MethodBodyItem_MaxStack @bindbody.maxstack
            : MSCIL.MethodBodyItem_Locals False @bindbody.locals
            : @bindbody.instr
            )
          ]
        )
  | LetCont bindbody.localoffset = 0
  | LetCont bindbody.env =
      Map.fromList $
        (@loc.valuekey, Argument 1) :
        (zip @loc.upvalues $ map ((Field (Argument 0) (MSCIL.convert @loc.classname)) . MSCIL.convert) @loc.upvalues)
  | LetCont lhs.classes = @loc.class : (@bindbody.classes ++ @body.classes)
  | LetCont (loc.upvalueinstr, loc.upvaluemaxstack) = unzip $ map (readEnv @lhs.env) @loc.upvalues
  | LetCont lhs.instr =
      (concat @loc.upvalueinstr) ++
      [ MSCIL.instrNewObj MSCIL.callConv_Instance MSCIL.Type_Void @loc.classname MSCIL.MethodName_Ctor @loc.upvalues
      , MSCIL.instrStLoc @loc.target
      ] ++
      @body.instr
  | LetCont body.env = Map.insert @contkey (Local @loc.target) @lhs.env
  | LetCont lhs.maxstack = foldl max @body.maxstack (zipWith (+) (@loc.upvaluemaxstack ++ [0]) [0..])

----
-- LetThunk
----
SEM CTm
  | LetThunk lhs.locals = (map MSCIL.convert @binds.locals) ++ @body.locals
  | LetThunk body.env = Map.union (Map.fromList $ zip @binds.locals $ map Local [@lhs.localoffset ..]) @lhs.env
  | LetThunk body.localoffset = @lhs.localoffset + (length @binds.locals)
  | LetThunk lhs.instr = @binds.allocinstr ++ @binds.fixupinstr ++ @body.instr
  | LetThunk lhs.maxstack = foldr1 max [@binds.allocmaxstack, @binds.fixupmaxstack, @body.maxstack]
  | LetThunk binds.recenv = Map.fromList $ zip @binds.locals $ map Local [@lhs.localoffset ..]

ATTR CThunkBind [ | | local : {EnvironmentKey} ]
ATTR CThunkBindL [ | | locals : {[EnvironmentKey]} ]
SEM CThunkBindL
  | Nil lhs.locals = []
  | Cons lhs.locals = @hd.local : @tl.locals
SEM CThunkBind
  | ThunkBind loc.classname = thunkClassName @thunkname
  | ThunkBind loc.thunkkey = asKey @thunkname
  | ThunkBind loc.contkey = asKey @contname
  | ThunkBind lhs.local = @loc.thunkkey
  
ATTR CThunkBind CThunkBindL [ localoffset : {Int} | | ]
SEM CThunkBindL
  | Cons tl.localoffset = @lhs.localoffset + 1

ATTR CThunkBind CThunkBindL [ env : {Environment} | | ]
ATTR CThunkBind CThunkBindL [ recenv : {Environment} | | ]
ATTR CThunkBind CThunkBindL [ | | allocinstr USE {++} {[]} : {MSCIL.MethodBodyItemL} allocmaxstack USE {max} {0} : {Int} ]
ATTR CThunkBind CThunkBindL [ | | classes USE {++} {[]} : {MSCIL.DeclL} ]
SEM CThunkBind
  | ThunkBind loc.upvalues = @body.freevars `Set.difference` (Set.fromList [@loc.thunkkey, @loc.contkey])
  | ThunkBind loc.nonrecupvalues = Set.toList $ @loc.upvalues `Set.difference` (Map.keysSet @lhs.recenv)
  | ThunkBind loc.recupvalues = Set.toList $ @loc.upvalues `Set.intersection` (Map.keysSet @lhs.recenv)
  | ThunkBind loc.allupvalues = @loc.recupvalues ++ @loc.nonrecupvalues
  | ThunkBind lhs.classes =
      [ MSCIL.Decl_Class
          ( MSCIL.classHeader
            [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi]
            @loc.classname
            [thunkBase]
          )
          (
            map (MSCIL.ClassMember_Field . MSCIL.convert) (@loc.nonrecupvalues ++ @loc.recupvalues) ++
            [ MSCIL.ClassMember_Method
              ( MSCIL.ctorHeader @loc.nonrecupvalues )
              (
                [ MSCIL.instrLdArg 0
                , MSCIL.instrCall MSCIL.callConv_Instance MSCIL.Type_Void thunkBase MSCIL.MethodName_Ctor ()
                ] ++
                ( concat $ map
                    (\(upval, index) -> 
                      [ MSCIL.instrLdArg 0
                      , MSCIL.instrLdArg index
                      , MSCIL.instrStFld upval @loc.classname upval
                      ]
                    )
                    (zip @loc.nonrecupvalues [1..])
                ) ++ 
                [ MSCIL.instrRet ]
              )
          , MSCIL.ClassMember_Method
              ( MSCIL.methodHeader
                [MSCIL.MethAttr_Public, MSCIL.MethAttr_Family]
                MSCIL.callConv_Instance
                MSCIL.Type_Void
                "Fixup"
                @loc.recupvalues
              )
              (
                (concat $ map
                  (\(upval, index) -> 
                    [ MSCIL.instrLdArg 0
                    , MSCIL.instrLdArg index
                    , MSCIL.instrStFld upval @loc.classname upval
                    ]
                  )
                  (zip @loc.recupvalues [1..])
                ) ++
                [ MSCIL.instrRet ]
              )
          , MSCIL.ClassMember_Method
              ( MSCIL.methodHeader
                [MSCIL.MethAttr_Public, MSCIL.MethAttr_Family, MSCIL.MethAttr_Virtual]
                MSCIL.callConv_Instance
                MSCIL.Type_Void
                "Eval"
                [@loc.contkey]
              )
              ( MSCIL.MethodBodyItem_MaxStack @body.maxstack
              : MSCIL.MethodBodyItem_Locals False @body.locals
              : @body.instr
              )
            ]
          )
      ] ++ @body.classes
  | ThunkBind (loc.nonrecupvalinstr, loc.nonrecupvalmaxstack) = unzip $ map (readEnv @lhs.env) @loc.nonrecupvalues
  | ThunkBind lhs.allocinstr = 
      (concat @loc.nonrecupvalinstr) ++
      [ MSCIL.instrNewObj MSCIL.callConv_Instance MSCIL.Type_Void @loc.classname MSCIL.MethodName_Ctor @loc.nonrecupvalues
      , MSCIL.instrStLoc @lhs.localoffset
      ]
  | ThunkBind lhs.allocmaxstack = foldr max ((length @loc.nonrecupvalues) + 1) (zipWith (+) @loc.nonrecupvalmaxstack [0..])
  | ThunkBind body.localoffset = 0
  | ThunkBind body.env =
      Map.fromList $
        (@loc.thunkkey, Argument 0) :
        (@loc.contkey, Argument 1) :
        (zip @loc.allupvalues $ map ((Field (Argument 0) (MSCIL.convert @loc.classname)) . MSCIL.convert) @loc.allupvalues)

ATTR CThunkBind CThunkBindL [ | | fixupinstr USE {++} {[]} : {MSCIL.MethodBodyItemL} fixupmaxstack USE {max} {0} : {Int} ]
SEM CThunkBind
  | ThunkBind (loc.recupvalinstr, loc.recupvalmaxstack) = unzip $ map (readEnv @lhs.recenv) @loc.recupvalues
  | ThunkBind lhs.fixupinstr = 
      [ MSCIL.instrLdLoc @lhs.localoffset ] ++
      (concat @loc.recupvalinstr) ++
      [ MSCIL.instrCall MSCIL.callConv_Instance MSCIL.Type_Void @loc.classname "Fixup" @loc.recupvalues ]
  | ThunkBind lhs.fixupmaxstack = foldl max ((length @loc.recupvalues) + 1) (zipWith (+) @loc.recupvalmaxstack [1..])

----
-- ContAppl
----
SEM CTm
  | ContAppl lhs.locals = []
  | ContAppl loc.contkey = asKey @cont
  | ContAppl loc.valuekey = asKey @val
  | ContAppl (loc.continstr,loc.contmaxstack) = readEnv @lhs.env @loc.contkey
  | ContAppl (loc.valinstr,loc.valmaxstack) = readEnv @lhs.env @loc.valuekey
  | ContAppl lhs.instr =
      @loc.continstr ++ @loc.valinstr ++
      [ MSCIL.instrTail
      , MSCIL.instrCallVirt MSCIL.callConv_Instance MSCIL.Type_Void continuationBase "Invoke" [@loc.valuekey]
      , MSCIL.instrRet
      ]
  | ContAppl lhs.maxstack =
      @loc.contmaxstack `max`
      (@loc.valmaxstack + 1) `max`
      2

----
-- ThunkEval
----
SEM CTm
  | ThunkEval lhs.locals = []
  | ThunkEval loc.thunkkey = asKey @thunk
  | ThunkEval loc.contkey = asKey @cont
  | ThunkEval (loc.thunkinstr, loc.thunkmaxstack) = readEnv @lhs.env @loc.thunkkey
  | ThunkEval (loc.continstr, loc.contmaxstack) = readEnv @lhs.env @loc.contkey
  | ThunkEval lhs.instr =
      @loc.thunkinstr ++ @loc.continstr ++
      [ MSCIL.instrTail
      , MSCIL.instrCallVirt MSCIL.callConv_Instance MSCIL.Type_Void thunkBase "Eval" [@loc.contkey]
      , MSCIL.instrRet
      ]
  | ThunkEval lhs.maxstack =
      @loc.thunkmaxstack `max`
      (@loc.contmaxstack + 1) `max`
      2

----
-- FuncAppl
----
SEM CTm
  | FuncAppl lhs.locals = []
  | FuncAppl loc.funckey = asKey @func
  | FuncAppl loc.contkey = asKey @cont
  | FuncAppl loc.argkey = asKey @arg
  | FuncAppl (loc.funcinstr, loc.funcmaxstack) = readEnv @lhs.env @loc.funckey
  | FuncAppl (loc.continstr, loc.contmaxstack) = readEnv @lhs.env @loc.contkey
  | FuncAppl (loc.arginstr, loc.argmaxstack) = readEnv @lhs.env @loc.argkey
  | FuncAppl lhs.instr =
      @loc.funcinstr ++ @loc.continstr ++ @loc.arginstr ++
      [ MSCIL.instrTail
      , MSCIL.instrCallVirt MSCIL.callConv_Instance MSCIL.Type_Void functionBase "Invoke" [@loc.contkey, @loc.argkey]
      , MSCIL.instrRet
      ]
  | FuncAppl lhs.maxstack =
      @loc.funcmaxstack `max`
      (@loc.contmaxstack + 1) `max`
      (@loc.argmaxstack + 2) `max`
      3

---
-- Exit
----
SEM CTm
  | Exit (loc.valinstr, loc.valmaxstack) = readEnv @lhs.env (asKey @val)
  | Exit lhs.instr =
      @loc.valinstr ++
      [ MSCIL.instrTail
      , MSCIL.instrCall MSCIL.CallKind_Default MSCIL.Type_Void systemConsoleRefType "WriteLine" [MSCIL.Type_Object]
      , MSCIL.instrRet
      ]
  | Exit lhs.maxstack = max 1 @loc.valmaxstack
  | Exit lhs.locals = []

----
-- Case
----
ATTR CTm CVal CCaseBranch CCaseBranchL CThunkBind CThunkBindL [ | caseNumber : {Int} | ]
SEM CTm
  | Case loc.valenv = asKey @val
  | Case loc.currentNumber = @lhs.caseNumber
  | Case lhs.caseNumber = @lhs.caseNumber + 1
  | Case loc.classname = MSCIL.convert $ "CaseSwitch" ++ (show @loc.currentNumber)
  | Case loc.branchclass = MSCIL.convert @loc.classname
  | Case branches.index = 0
  | Case lhs.locals = []
--      if @branches.needlocal
--        then [MSCIL.Variable_Variable MSCIL.Type_Object Nothing]
--        else []
  | Case branches.templocal = @lhs.localoffset
  | Case lhs.classes =
      (
        MSCIL.Decl_Class
          ( MSCIL.classHeader
            [MSCIL.ClassAttr_Public, MSCIL.ClassAttr_Auto, MSCIL.ClassAttr_Ansi]
            @loc.classname
          )
          @branches.methods
      )
      : @branches.classes
  | Case lhs.instr =
      @branches.instr ++
      ( if @branches.hasDefault
          then []
          else
            (
              (debugOutputInstrs $ "ERROR: Case fallthrough, none of the cases matched the value at case switch " ++ (show @loc.currentNumber)) ++
              [ MSCIL.instrRet ]
            )
      ) ++
      @branches.finalinstr

ATTR CCaseBranch CCaseBranchL CCasePattern [ | | hasDefault USE {||} {False} : {Bool} ]
SEM CCasePattern
  | Default lhs.hasDefault = True

ATTR CCaseBranch CCaseBranchL CCasePattern [ | | classes USE {++} {[]} : {MSCIL.DeclL} ]
ATTR CCaseBranch CCaseBranchL [ valenv : {EnvironmentKey} | | ]
ATTR CCaseBranch CCaseBranchL [ env : {Environment} | | ]
ATTR CCaseBranch [ | | instr : {MSCIL.MethodBodyItemL} maxstack : {Int} ]
ATTR CCaseBranch [ | | finalinstr : {MSCIL.MethodBodyItemL} ]
ATTR CCaseBranchL [ | | instr USE {++} {[]} : {MSCIL.MethodBodyItemL} maxstack USE {max} {0} : {Int} ]
ATTR CCaseBranchL [ | | finalinstr USE {++} {[]} : {MSCIL.MethodBodyItemL} ]
ATTR CCaseBranch CCaseBranchL [ classname : {MSCIL.Id} index : {Int} | | ]
SEM CCaseBranchL
  | Cons tl.index = @lhs.index + 1
SEM CCaseBranch
  | CaseBranch loc.branchmethod = MSCIL.convert $ "branch" ++ (show @lhs.index)
  | CaseBranch loc.upvalues = Set.toList @body.freevars
  | CaseBranch pat.bodyupvalues = @loc.upvalues
  | CaseBranch body.localoffset = 0
  | CaseBranch body.env = Map.fromList $ zip @loc.upvalues (map Argument [0..])
  | CaseBranch lhs.instr = @pat.instr
  | CaseBranch lhs.finalinstr = @pat.finalinstr
  | CaseBranch lhs.maxstack = @pat.maxstack

ATTR CCaseBranch [ | | methods : {MSCIL.ClassMember} ]
ATTR CCaseBranchL [ | | methods USE {:} {[]} : {MSCIL.ClassMemberL} ]
SEM CCaseBranch
  | CaseBranch lhs.methods =
      MSCIL.ClassMember_Method
        ( MSCIL.methodHeader
          [MSCIL.MethAttr_Public, MSCIL.MethAttr_Static]
          MSCIL.Type_Void
          @loc.branchmethod
          @loc.upvalues
        )
        (
          [ MSCIL.MethodBodyItem_MaxStack @body.maxstack
          , MSCIL.MethodBodyItem_Locals False @body.locals
          ] ++
          @body.instr
        )

ATTR CCasePattern [ | | instr : {MSCIL.MethodBodyItemL} maxstack : {Int} ]
ATTR CCasePattern [ | | finalinstr : {MSCIL.MethodBodyItemL} ]
ATTR CCasePattern [ valenv : {EnvironmentKey} | | ]
ATTR CCasePattern [ index : {Int} | | ]
ATTR CCasePattern CCaseBranch CCaseBranchL [ branchclass : {MSCIL.TypeSpec} | | ]
ATTR CCasePattern [ branchmethod : {MSCIL.MethodName} upvalues : {[EnvironmentKey]} | | ]
ATTR CCasePattern [ env : {Environment} | | ]
ATTR CCasePattern [ bodyupvalues : {[EnvironmentKey]} | | ]
SEM CCasePattern
  | Default (loc.upvalueinstr, loc.upvaluemaxstack) = unzip $ map (readEnv @lhs.env) @lhs.bodyupvalues
  | Default lhs.instr = 
      (concat @loc.upvalueinstr) ++ 
      [ MSCIL.instrTail
      , MSCIL.instrCall MSCIL.CallKind_Default MSCIL.Type_Void @lhs.branchclass @lhs.branchmethod @lhs.bodyupvalues
      , MSCIL.instrRet
      ]
  | Default lhs.finalinstr = []
  | Default lhs.maxstack = foldl max (length @lhs.bodyupvalues) (zipWith (+) @loc.upvaluemaxstack [0..])
  | Tag (loc.valinstr, loc.valmaxstack) = readEnv @lhs.env @lhs.valenv
  | Tag loc.classname = tagClassName @tag $ length @args
  | Tag loc.label = MSCIL.convert $ "Branch" ++ (show @lhs.index)
  | Tag loc.valloc = fromJust $ Map.lookup @lhs.valenv @lhs.env
  | Tag loc.fieldkeys = map asKey @args
  | Tag loc.fieldlocs =
      map
        (\index ->
          Field
            @loc.valloc
            (MSCIL.convert @loc.classname)
            (tagFieldName index)
        )
        [1..]
  | Tag loc.fieldenv = Map.fromList $ zip @loc.fieldkeys @loc.fieldlocs
  | Tag loc.restenv =
      case @rest of
        Nothing -> Map.empty
        Just restname -> Map.singleton (asKey restname) @loc.valloc
  | Tag loc.newenv = @loc.restenv `Map.union` @loc.fieldenv `Map.union` @lhs.env
  | Tag (loc.upvalueinstr, loc.upvaluemaxstack) = unzip $ map (readEnv @loc.newenv) @lhs.bodyupvalues
  | Tag lhs.instr =
      @loc.valinstr
      ++
      [ MSCIL.instrIsInst @loc.classname
      , MSCIL.instrBrTrue @loc.label
      ]
  | Tag lhs.finalinstr =
      [ MSCIL.MethodBodyItem_Label @loc.label ] ++
      (concat @loc.upvalueinstr) ++
      [ MSCIL.instrTail
      , MSCIL.instrCall MSCIL.CallKind_Default MSCIL.Type_Void @lhs.branchclass @lhs.branchmethod @lhs.bodyupvalues
      , MSCIL.instrRet
      ]
  | Tag lhs.maxstack = foldl max (length @lhs.bodyupvalues) $ @loc.valmaxstack : (zipWith (+) @loc.upvaluemaxstack [0..])
----
-- Free and bound variables
----
-- Should go in a shared AG file.
ATTR CTm CVal [ | | freevars : {Set.Set EnvironmentKey} ]
ATTR CThunkBind CThunkBindL [ | | freevars USE {Set.union} {Set.empty} : {Set.Set EnvironmentKey} boundvars USE {Set.union} {Set.empty} : {Set.Set EnvironmentKey} ]
SEM CTm
  | LetVal lhs.freevars = @bindvalue.freevars `Set.union` (Set.delete (asKey @bindname) @body.freevars)
  | LetCont lhs.freevars = (Set.delete @loc.valuekey @bindbody.freevars) `Set.union` (Set.delete @loc.contkey @body.freevars)
  -- Let op, alleen let thunk kan recursief zijn eigen binds zien.
  | LetThunk lhs.freevars = (@binds.freevars `Set.union` @body.freevars) `Set.difference` @binds.boundvars
  | ContAppl lhs.freevars = Set.fromList [asKey @cont, asKey @val]
  | ThunkEval lhs.freevars = Set.fromList [asKey @thunk, asKey @cont]
  | FuncAppl lhs.freevars = Set.fromList [asKey @func, asKey @cont, asKey @arg]
  | Exit lhs.freevars = Set.fromList [asKey @val]
  | Case lhs.freevars = @branches.freevars

SEM CVal
  | IntVal StringVal lhs.freevars = Set.empty
  | LamVal lhs.freevars = @body.freevars `Set.difference` (Set.fromList [asKey @bindcont, asKey @bindarg])
  | TagVal lhs.freevars = Set.fromList $ map asKey @args

SEM CThunkBind
  | ThunkBind lhs.boundvars = Set.fromList [asKey @thunkname]
  | ThunkBind lhs.freevars = Set.delete (asKey @contname) @body.freevars

ATTR CCasePattern [ | | boundvars : {Set.Set EnvironmentKey} ]
SEM CCasePattern
  | Default lhs.boundvars = Set.empty
  | Tag loc.restboundvars =
      case @rest of
        Nothing -> Set.empty
        Just x -> Set.singleton $ asKey x
  | Tag lhs.boundvars = @loc.restboundvars `Set.union` (Set.fromList $ map asKey @args)
  | Int lhs.boundvars = Set.empty

ATTR CCaseBranch [ | | boundvars : {Set.Set EnvironmentKey} ]
ATTR CCaseBranch [ | | freevars : {Set.Set EnvironmentKey} ]
ATTR CCaseBranchL [ | | boundvars USE {Set.union} {Set.empty} : {Set.Set EnvironmentKey} ]
ATTR CCaseBranchL [ | | freevars USE {Set.union} {Set.empty} : {Set.Set EnvironmentKey} ]
SEM CCaseBranch
  | CaseBranch loc.boundvars = @pat.boundvars
  | CaseBranch lhs.freevars = @body.freevars `Set.difference` @pat.boundvars
%%]
