%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 core) hs module {%{EH}CoreCPS.Trf.Inline} import({%{EH}CoreCPS}, {%{EH}Ty}, qualified Data.Map.Strict as Map, {%{EH}Base.HsName}, Data.Maybe)
%%]

%%[(8 core).WRAPPER ag import({CoreCPS/AbsSyn})
WRAPPER CTm
%%]

%%[(8 core) hs export(ctmTrfInline)
ctmTrfInline :: CTm -> CTm
ctmTrfInline ctm
  = let t = wrap_CTm (sem_CTm ctm)
            ( Inh_CTm
              { replace_Inh_CTm = replaceMapEmpty
              , inlineId_Inh_CTm = 0
              , nextInlineId_Inh_CTm = 1
              }
            )
    in inlined_Syn_CTm t
%%]

%%[(8 core) hs
data ReplaceMap =
  ReplaceMap
    { valueReplace :: Map.Map ValueName (ValueName, Maybe ValueInlineInfo)
    , contReplace :: Map.Map ContName (ContName, Maybe ContInlineInfo)
    , thunkReplace :: Map.Map ThunkName (ThunkName, Maybe ThunkInlineInfo)
    }

type ValueInlineInfo = (CTm, ReplaceMap, ContName, [ThunkName])
type ContInlineInfo = (CTm, ReplaceMap, ValueName)
type ThunkInlineInfo = (CTm, ReplaceMap, ContName)

applyReplaceMap :: CTm -> ReplaceMap -> Int -> (CTm, Int)
applyReplaceMap ctm rep inlineId
  = let t = wrap_CTm (sem_CTm ctm)
            ( Inh_CTm
              { replace_Inh_CTm = rep
              , inlineId_Inh_CTm = inlineId
              , nextInlineId_Inh_CTm = inlineId + 1
              }
            )
    in (inlined_Syn_CTm t, nextInlineId_Syn_CTm t)

infoValueName :: ReplaceMap -> ValueName -> (ValueName, Maybe ValueInlineInfo)
infoValueName r v = Map.findWithDefault (v, Nothing) v (valueReplace r)

infoContName :: ReplaceMap -> ContName -> (ContName, Maybe ContInlineInfo)
infoContName r c = Map.findWithDefault (c, Nothing) c (contReplace r) 

infoThunkName :: ReplaceMap -> ThunkName -> (ThunkName, Maybe ThunkInlineInfo)
infoThunkName r t = Map.findWithDefault (t, Nothing) t (thunkReplace r)

replaceValueName :: ReplaceMap -> ValueName -> ValueName
replaceValueName m v = fst (infoValueName m v)

replaceContName :: ReplaceMap -> ContName -> ContName
replaceContName m c = fst (infoContName m c)

replaceThunkName :: ReplaceMap -> ThunkName -> ThunkName
replaceThunkName m t = fst (infoThunkName m t)

deleteValue :: ValueName -> ReplaceMap -> ReplaceMap
deleteValue v r = r { valueReplace = Map.delete v (valueReplace r) }

deleteCont :: ContName -> ReplaceMap -> ReplaceMap
deleteCont c r = r { contReplace = Map.delete c (contReplace r) }

deleteThunk :: ThunkName -> ReplaceMap -> ReplaceMap
deleteThunk t r = r { thunkReplace = Map.delete t (thunkReplace r) }

insertValue :: ValueName -> (ValueName, Maybe ValueInlineInfo) -> ReplaceMap -> ReplaceMap
insertValue k v r = r { valueReplace = Map.insert k v (valueReplace r) }

insertCont :: ContName -> (ContName, Maybe ContInlineInfo) -> ReplaceMap -> ReplaceMap
insertCont k v r = r { contReplace = Map.insert k v (contReplace r) }

insertThunk :: ThunkName -> (ThunkName, Maybe ThunkInlineInfo) -> ReplaceMap -> ReplaceMap
insertThunk k v r = r { thunkReplace = Map.insert k v (thunkReplace r) }

replaceUnion :: ReplaceMap -> ReplaceMap -> ReplaceMap
replaceUnion (ReplaceMap a1 a2 a3) (ReplaceMap b1 b2 b3) = ReplaceMap (Map.union a1 b1) (Map.union a2 b2) (Map.union a3 b3)

replaceMapEmpty :: ReplaceMap
replaceMapEmpty = ReplaceMap Map.empty Map.empty Map.empty
%%]

%%[(8 core) hs
trfValueName :: ValueName -> Int -> ValueName
trfValueName (ValueName hsn) n = ValueName (hsnUniqifyInt HsNameUniqifier_Inline n hsn)

trfContName :: ContName -> Int -> ContName
trfContName (ContName hsn) n = ContName (hsnUniqifyInt HsNameUniqifier_Inline n hsn)

trfThunkName :: ThunkName -> Int -> ThunkName
trfThunkName (ThunkName hsn) n = ThunkName (hsnUniqifyInt HsNameUniqifier_Inline n hsn)
%%]

%%[(8 core)
ATTR CTm CVal CThunkBind CThunkBindL CCasePattern CCaseBranch CCaseBranchL [ replace : {ReplaceMap} | | ]
ATTR CTm CVal CThunkBind CThunkBindL CCasePattern CCaseBranch CCaseBranchL [ inlineId : {Int} | nextInlineId : {Int} | ]
ATTR CTm CVal CThunkBind CThunkBindL CCasePattern CCaseBranch CCaseBranchL [ | | inlined : SELF original: SELF ]

ATTR CVal [ | | inlineInfo : {Maybe ValueInlineInfo} ]

SEM CVal
  | * - LamVal lhs.inlineInfo = Nothing
  | LamVal loc.newBindCont = trfContName @bindcont @lhs.inlineId
  | LamVal loc.newBindArg = trfThunkName @bindarg @lhs.inlineId
  | LamVal loc.replace = insertCont @bindcont (@loc.newBindCont, Nothing) (insertThunk @bindarg (@loc.newBindArg, Nothing) @lhs.replace)
  | LamVal body.replace = @loc.replace
  | LamVal lhs.inlineInfo =
      case @loc.shouldInline of
        False -> Nothing
        True -> Just (@body.original, @loc.replace, @bindcont, [@bindarg])
  | LamVal lhs.inlined = CVal_LamVal @loc.newBindCont @loc.newBindArg @body.inlined
  | TagVal lhs.inlined = CVal_TagVal @tag (map (replaceThunkName @lhs.replace) @args)
  | FFIVal lhs.inlined = CVal_FFIVal @instr (map (replaceValueName @lhs.replace) @args) @ty

SEM CTm
  | LetVal loc.newBindName = trfValueName @bindname @lhs.inlineId
  | LetVal body.replace = insertValue @bindname (@loc.newBindName, @bindvalue.inlineInfo) @lhs.replace
  | LetVal lhs.inlined = CTm_LetVal @loc.newBindName @bindvalue.inlined @body.inlined

SEM CTm
  | LetCont loc.newContName = trfContName @contname @lhs.inlineId
  | LetCont loc.newValName = trfValueName @valname @lhs.inlineId
  | LetCont loc.contReplace = insertValue @valname (@loc.newValName, Nothing) @lhs.replace
  | LetCont bindbody.replace = @loc.contReplace
  | LetCont loc.inlineInfo =
      case @loc.shouldInline of
        False -> Nothing
        True -> Just (@bindbody.original, @loc.contReplace, @valname)
  | LetCont body.replace =
      insertCont @contname (@loc.newContName, @loc.inlineInfo) @lhs.replace
  | LetCont lhs.inlined =
      CTm_LetCont @loc.newContName @loc.newValName @bindbody.inlined @body.inlined

SEM CTm
  | LetThunk binds.replace =
      ( foldr
        (\(x,y) -> insertThunk x (y, Nothing))
        @lhs.replace
        (zip @binds.names @binds.newNames)
      )
  | LetThunk body.replace =
      ( foldr
        (\(x,y) -> insertThunk x y)
        @lhs.replace
        (zip @binds.names (zip @binds.newNames @binds.inlines))
      )

ATTR CThunkBind [ | | inlines : {Maybe ThunkInlineInfo} ]
ATTR CThunkBind [ | | names : {ThunkName} ]
ATTR CThunkBind [ | | newNames : {ThunkName} ]
ATTR CThunkBindL [ | | inlines USE {:} {[]} : {[Maybe ThunkInlineInfo]} ]
ATTR CThunkBindL [ | | names USE {:} {[]} : {[ThunkName]} ]
ATTR CThunkBindL [ | | newNames USE {:} {[]} : {[ThunkName]} ]

SEM CThunkBind
  | ThunkBind lhs.names = @thunkname
  | ThunkBind loc.newThunkName = trfThunkName @thunkname @lhs.inlineId
  | ThunkBind loc.newContName = trfContName @contname @lhs.inlineId
  | ThunkBind lhs.newNames = @loc.newThunkName
  | ThunkBind lhs.inlines =
      case @loc.shouldInline of
        False -> Nothing
        True -> Just (@body.original, @lhs.replace, @contname)
  | ThunkBind body.replace = insertCont @contname (@loc.newContName, Nothing) @lhs.replace
  | ThunkBind lhs.inlined = CThunkBind_ThunkBind @loc.newThunkName @loc.newContName @body.inlined

SEM CTm
  | ContAppl (loc.newContName, loc.contInline) = infoContName @lhs.replace @cont
  | ContAppl loc.valInfo = infoValueName @lhs.replace @val
  | ContAppl (lhs.inlined, lhs.nextInlineId) =
      case @loc.contInline of
        Nothing ->
          ( CTm_ContAppl
            @loc.newContName
            (fst @loc.valInfo)
          , @lhs.nextInlineId
          )
        Just (body, replace, valname) ->
          applyReplaceMap
            body
            (insertValue valname @loc.valInfo replace)
            @lhs.nextInlineId

SEM CTm
  | ThunkEval (loc.newThunkName, loc.thunkInline) = infoThunkName @lhs.replace @thunk
  | ThunkEval loc.contInfo = infoContName @lhs.replace @cont
  | ThunkEval (lhs.inlined, lhs.nextInlineId) =
      case @loc.thunkInline of
        Nothing ->
          ( CTm_ThunkEval
            @loc.newThunkName
            (fst @loc.contInfo)
          , @lhs.nextInlineId
          )
        Just (body, replace, contname) ->
          applyReplaceMap
            body
            (insertCont contname @loc.contInfo replace)
            @lhs.nextInlineId

SEM CTm
  | FuncAppl (loc.newFuncName, loc.funcInline) = infoValueName @lhs.replace @func
  | FuncAppl loc.contInfo = infoContName @lhs.replace @cont
  | FuncAppl loc.argInfo = infoThunkName @lhs.replace @arg
  | FuncAppl (lhs.inlined, lhs.nextInlineId) =
      case @loc.funcInline of
        Nothing ->
          ( CTm_FuncAppl
            @loc.newFuncName
            (fst @loc.contInfo)
            (fst @loc.argInfo)
          , @lhs.nextInlineId
          ) 
        Just (body, replace, contname, argnames) ->
          applyReplaceMap
            body
            ( foldr
              (\(k, v) m -> insertThunk k v m)
              (insertCont contname @loc.contInfo replace)
              (zip argnames [@loc.argInfo])
            )
            @lhs.nextInlineId

SEM CTm
  | Exit loc.newValName = replaceValueName @lhs.replace @val
  | Exit lhs.inlined = CTm_Exit @loc.newValName

-- TODO: Update replacemap in case branches to delete pattern arguments.
-- TODO: Case

{-
-- When to inline?
-}

ATTR CVal [ | | isSimpleValue : {Bool} ]
SEM CVal
  | IntVal StringVal TagVal FFIVal lhs.isSimpleValue = True
  | LamVal lhs.isSimpleValue = False

ATTR CTm [ | | isThunkEval : {Bool} ]
SEM CTm
  | ThunkEval lhs.isThunkEval = True
  | * - ThunkEval lhs.isThunkEval = False

ATTR CTm [ | | isContAppl : {Bool} ]
SEM CTm
  | ContAppl lhs.isContAppl = True
  | * - ContAppl lhs.isContAppl = False

ATTR CTm [ | | isSimpleValContAppl : {Bool} ]
SEM CTm
  | LetVal lhs.isSimpleValContAppl = @bindvalue.isSimpleValue && @body.isContAppl
  | ContAppl lhs.isSimpleValContAppl = True
  | * - LetVal ContAppl lhs.isSimpleValContAppl = False

ATTR CTm [ | | isExit : {Bool} ]
SEM CTm
  | Exit lhs.isExit = True
  | * - Exit lhs.isExit = False

ATTR CTm [ | | isSimpleValExit : {Bool} ]
SEM CTm
  | LetVal lhs.isSimpleValExit = @bindvalue.isSimpleValue && @body.isExit
  | Exit lhs.isSimpleValExit = True
  | * - LetVal Exit lhs.isSimpleValExit = False
  

SEM CTm
  | LetCont loc.shouldInline = @bindbody.isSimpleValExit

SEM CThunkBind
  | ThunkBind loc.shouldInline = @body.isThunkEval || @body.isSimpleValContAppl

SEM CVal
  | LamVal loc.shouldInline = False

%%]

