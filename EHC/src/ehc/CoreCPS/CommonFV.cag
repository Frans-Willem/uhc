%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 core) hs
data VarSet
  = VarSet
      { thunkSet :: Set.Set ThunkName
      , valueSet :: Set.Set ValueName
      , contSet :: Set.Set ContName
      }

varSetEmpty :: VarSet
varSetEmpty = VarSet Set.empty Set.empty Set.empty

varSetSingleThunk :: ThunkName -> VarSet
varSetSingleThunk t = VarSet (Set.singleton t) Set.empty Set.empty

varSetSingleValue :: ValueName -> VarSet
varSetSingleValue v = VarSet Set.empty (Set.singleton v) Set.empty

varSetSingleCont :: ContName -> VarSet
varSetSingleCont c = VarSet Set.empty Set.empty (Set.singleton c)

varSetFromThunkList :: [ThunkName] -> VarSet
varSetFromThunkList tl = VarSet (Set.fromList tl) Set.empty Set.empty

varSetFromValueList :: [ValueName] -> VarSet
varSetFromValueList vl = VarSet Set.empty (Set.fromList vl) Set.empty

varSetDeleteThunk :: ThunkName -> VarSet -> VarSet
varSetDeleteThunk t (VarSet ts vs cs) = VarSet (Set.delete t ts) vs cs

varSetDeleteValue :: ValueName -> VarSet -> VarSet
varSetDeleteValue v (VarSet ts vs cs) = VarSet ts (Set.delete v vs) cs

varSetDeleteCont :: ContName -> VarSet -> VarSet
varSetDeleteCont c (VarSet ts vs cs) = VarSet ts vs (Set.delete c cs)

varSetUnion :: VarSet -> VarSet -> VarSet
varSetUnion (VarSet a1 a2 a3) (VarSet b1 b2 b3) = VarSet (a1 `Set.union` b1) (a2 `Set.union` b2) (a3 `Set.union` b3)

varSetDifference :: VarSet -> VarSet -> VarSet
varSetDifference (VarSet a1 a2 a3) (VarSet b1 b2 b3) = VarSet (a1 `Set.difference` b1) (a2 `Set.difference` b2) (a3 `Set.difference` b3)

varSetIntersection :: VarSet -> VarSet -> VarSet
varSetIntersection (VarSet a1 a2 a3) (VarSet b1 b2 b3) = VarSet (a1 `Set.intersection` b1) (a2 `Set.intersection` b2) (a3 `Set.intersection` b3)

varSetNull :: VarSet -> Bool
varSetNull (VarSet ts vs cs) = (Set.null ts) && (Set.null vs) && (Set.null cs)

varSetThunkMember :: ThunkName -> VarSet -> Bool
varSetThunkMember t (VarSet ts _ _) = Set.member t ts
varSetValueMember :: ValueName -> VarSet -> Bool
varSetValueMember v (VarSet _ vs _) = Set.member v vs
varSetContMember :: ContName -> VarSet -> Bool
varSetContMember c (VarSet _ _ cs) = Set.member c cs
%%]

%%[(8 core)
ATTR CVal CBind CBindL CCaseBranch CCaseBranchL CTm [ | | freeVars USE {varSetUnion} {varSetEmpty} : {VarSet} ]

SEM CVal
  | LamVal loc.freeVars = (varSetDeleteCont @bindcont @body.freeVars) `varSetDifference` (varSetFromThunkList @bindargs)
  | TagVal loc.freeVars = varSetFromThunkList @args

SEM CBind
  | ThunkBind loc.freeVars = varSetDeleteCont @contname @body.freeVars

SEM CCaseBranch
  | CaseBranch loc.freeVars = @body.freeVars `varSetDifference` @pat.boundVars

SEM CTm
  | LetCont loc.freeVars = (varSetDeleteValue @valname @bindbody.freeVars) `varSetUnion` (varSetDeleteCont @contname @body.freeVars)
  | LetFFI loc.freeVars = (varSetFromValueList @args) `varSetUnion` (varSetDeleteValue @valname @body.freeVars)
  | Let loc.freeVars = (@binds.freeVars `varSetUnion` @body.freeVars) `varSetDifference` @binds.boundVars
  | ContAppl loc.freeVars = (varSetSingleCont @cont) `varSetUnion` (varSetSingleValue @val)
  | ThunkEval loc.freeVars = (varSetSingleThunk @thunk) `varSetUnion` (varSetSingleCont @cont)
  | FuncAppl loc.freeVars = (varSetSingleValue @func) `varSetUnion` (varSetSingleCont @cont) `varSetUnion` (varSetFromThunkList @args)
  | Exit loc.freeVars = varSetSingleValue @val
  | Case loc.freeVars = (varSetSingleValue @val) `varSetUnion` @branches.freeVars

ATTR CBind CBindL CCasePattern [ | | boundVars USE {varSetUnion} {varSetEmpty} : {VarSet} ]

SEM CBind
  | ThunkBind loc.boundVars = varSetSingleThunk @thunkname
  | ValBind loc.boundVars = varSetSingleValue @valname

SEM CCasePattern
  | Tag loc.boundVars = varSetFromThunkList ((maybeToList @rest) ++ @args)
%%]
