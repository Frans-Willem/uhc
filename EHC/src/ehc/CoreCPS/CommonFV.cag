%%[0 lhs2tex
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%[(8 core) hs
data CPSVar
  = CPSValue ValueName
  | CPSThunk ThunkName
  | CPSCont ContName
  deriving (Eq, Ord)

type VarSet = Set.Set CPSVar

varSetEmpty :: VarSet
varSetEmpty = Set.empty

varSetSingleThunk :: ThunkName -> VarSet
varSetSingleThunk = Set.singleton . CPSThunk

varSetSingleValue :: ValueName -> VarSet
varSetSingleValue = Set.singleton . CPSValue

varSetSingleCont :: ContName -> VarSet
varSetSingleCont = Set.singleton . CPSCont

varSetFromThunkList :: [ThunkName] -> VarSet
varSetFromThunkList = Set.fromList . (map CPSThunk)

varSetFromValueList :: [ValueName] -> VarSet
varSetFromValueList = Set.fromList . (map CPSValue)

varSetDeleteThunk :: ThunkName -> VarSet -> VarSet
varSetDeleteThunk = Set.delete . CPSThunk

varSetDeleteValue :: ValueName -> VarSet -> VarSet
varSetDeleteValue = Set.delete . CPSValue

varSetDeleteCont :: ContName -> VarSet -> VarSet
varSetDeleteCont = Set.delete . CPSCont

varSetUnion :: VarSet -> VarSet -> VarSet
varSetUnion = Set.union

varSetDifference :: VarSet -> VarSet -> VarSet
varSetDifference = Set.difference

varSetIntersection :: VarSet -> VarSet -> VarSet
varSetIntersection = Set.intersection

varSetNull :: VarSet -> Bool
varSetNull = Set.null

varSetThunkMember :: ThunkName -> VarSet -> Bool
varSetThunkMember = Set.member . CPSThunk
varSetValueMember :: ValueName -> VarSet -> Bool
varSetValueMember = Set.member . CPSValue
varSetContMember :: ContName -> VarSet -> Bool
varSetContMember = Set.member . CPSCont
%%]

%%[(8 core)
ATTR CVal CBind CBindL CCaseBranch CCaseBranchL CTm [ | | freeVars USE {varSetUnion} {varSetEmpty} : {VarSet} ]

SEM CVal
  | LamVal loc.freeVars = (varSetDeleteCont @bindcont @body.freeVars) `varSetDifference` (varSetFromThunkList @bindargs)
  | TagVal loc.freeVars = varSetFromThunkList @args

SEM CBind
  | ThunkBind loc.freeVars = varSetDeleteCont @contname @body.freeVars

SEM CCaseBranch
  | CaseBranch loc.freeVars = @body.freeVars `varSetDifference` @pat.boundVars

SEM CTm
  | LetCont loc.freeVars = (varSetDeleteValue @valname @bindbody.freeVars) `varSetUnion` (varSetDeleteCont @contname @body.freeVars)
  | LetFFI loc.freeVars = (varSetFromValueList @args) `varSetUnion` (varSetDeleteValue @valname @body.freeVars)
  | Let loc.freeVars = (@binds.freeVars `varSetUnion` @body.freeVars) `varSetDifference` @binds.boundVars
  | ContAppl loc.freeVars = (varSetSingleCont @cont) `varSetUnion` (varSetSingleValue @val)
  | ThunkEval loc.freeVars = (varSetSingleThunk @thunk) `varSetUnion` (varSetSingleCont @cont)
  | FuncAppl loc.freeVars = (varSetSingleValue @func) `varSetUnion` (varSetSingleCont @cont) `varSetUnion` (varSetFromThunkList @args)
  | Exit loc.freeVars = varSetSingleValue @val
  | Case loc.freeVars = (varSetSingleValue @val) `varSetUnion` @branches.freeVars

ATTR CBind CBindL CCasePattern [ | | boundVars USE {varSetUnion} {varSetEmpty} : {VarSet} ]

SEM CBind
  | ThunkBind loc.boundVars = varSetSingleThunk @thunkname
  | ValBind loc.boundVars = varSetSingleValue @valname

SEM CCasePattern
  | Tag loc.boundVars = varSetFromThunkList @args
%%]
